# 集合
### 集合框架图
![集合](java集合.png "集合")

### List(存储有序，可重复)
* **ArrayList**
不同步(需要同步的时候，可以使用Collections工具类来构建出同步的ArrayList而不用Vector)，Object数组，扩容0.5倍
* **LinkedList**
不同步，双向循环链表
* **Vector**
同步，Object数组，扩容一倍

### Set
* **HashSet**
HashMap，
   * **LinkedHashSet**
   LinkedHashMap
* **TreeSet**
红黑树

### Map
* **HashMap**
不同步，允许null作为键值
数组+链表，将拥有相同哈希值的对象组织成一个链表放在hash值所对应的bucket(桶)下，当HashMap中存在大量数据时，加入某个bucket下的对应的链表有N个元素，那么遍历的时间复杂度就为O(n)。JDK1.8在HashMap中，链表长度大于8时转换为红黑树，时间复杂度降为O(logn)。
* **TreeMap**
   * **LinkedHashMap**
* **ConcurrentHashMap**
* **HashTable**
同步，不允许null作为键值


### Hash
根据同一hash函数计算出的hash值如果不同，那么输入值肯定也不同。但是，根据同一hash函数计算出的hash值相同，输入值不一定相同。当输入值不同，hash值相同的现象就叫hash碰撞。

### Hash()函数
如果使用hashCode取余，那么相当于参与运算的只有hashCode的低位，高位是没有起到任何作用的，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为扰动，在JDK 1.8中的hash()函数如下：
```
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);// 与自己右移16位进行异或运算（高低位异或）
}
```
这比在JDK 1.7中，更为简洁，相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）。

### HashMap是使用了哪些方法来有效解决哈希冲突？
1. 使用链地址法（使用散列表）来链接拥有相同hash值的数据
2. 使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均
3. 引入红黑树进一步降低遍历的时间复杂度，使得遍历更快

### HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？
hashCode()方法返回的是int整数类型，其范围为-(2 ^ 31)~(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）~2 ^ 30，HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，**从而导致通过hashCode()计算出的哈希值可能不在数组大小范围内**，进而无法匹配存储位置。

### 怎么解决呢？
1. HashMap自己实现了自己的hash()方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均
2. 在保证数组长度为2的幂次方的时候，使用hash()运算之后的值与运算（&）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题

### 为什么数组长度要保证为2的幂次方呢？
1. 只有当数组长度为2的幂次方时，h&(length-1)才等价于h%length，即实现了key的定位，2的幂次方也可以减少冲突次数，提高HashMap的查询效率
2. 如果 length 为 2 的次幂 则 length-1 转化为二进制必定是 11111……的形式，在于 h 的二进制与操作效率会非常的快，而且空间不浪费；如果 length 不是 2 的次幂，比如 length 为 15，则 length - 1 为 14，对应的二进制为 1110，在于 h 与操作，最后一位都为 0 ，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！这样就会造成空间的浪费

### 为什么是两次扰动呢？
这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的；