# 时间复杂度与空间复杂度
## 时间复杂度
**算法效率的度量**
算法执行时间需通过依据该算法编制的程序在计算机上运行时所消耗的时间来度量。
* 事后统计的方法——因为很多计算机内部都有计时功能，有的甚至可精确到毫秒级，不同算法的程序可通过一组或者若干组相同的统计数据以分辨优劣。但这种方法有两个缺陷 ：一是必须先运行依据算法编制的程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素，有时容易掩盖算法本身的优势。
* 事后分析估算的方法——一个用高级程序语言编写的程序在计算机上运行时所消耗的时间取决于下列因素：
  * 依据的算法选用何种策略
  * **问题的规模，例如求100以内还是1000以内的素数**
  * 书写程序的语言，对于同一个算法，实现语言的级别越高，执行效率越低
  * 编译程序所产生的机器代码的质量
  * 机器执行指令的速度

一个算法是由控制结构（顺序、分支、循环）和原操作（指固有数据类型的操作）构成的，则算法时间取决于两者的综合效果。为了便于比较同一问题的不同算法，通常的做法是，从算法中选取一种对于所研究的问题（或算法类型）来说是基本操作的原操作，以该基本操作重复执行的次数作为算法的时间度量。

一般情况下，算法中基本操作重复执行的次数是**问题规模n**的某个函数f(n),算法的时间度量记作
    **T(n) = O(f(n))**
它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法渐进时间复杂度，简称时间复杂度。

有的情况下，算法中基本操作重复执行的次数还随问题的输入数据集不同而不同（冒泡排序……）。对这类算法的分析，一种解决办法是计算它的平均值，即考虑它对所有可能的输入数据集的期望值，此时对应的时间复杂度为算法的平均时间复杂度。另一种更可行也更常用的办法是讨论算法在最坏情况下的时间复杂度，即分析最坏情况以估算算法执行时间的一个上界。

**常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2n)＜Ο(n!)**

其中Ο(log2n)、Ο(n)、 Ο(nlog2n)、Ο(n2)和Ο(n3)称为多项式时间，而Ο(2n)和Ο(n!)称为指数时间。计算机科学家普遍认为前者（即多项式时间复杂度的算法）是有效算法，把这类问题称为P（Polynomial,多项式）类问题，而把后者（即指数时间复杂度的算法）称为NP（Non-Deterministic Polynomial, 非确定多项式）问题。

```
i=1;     ①  
hile (i<=n)  
  i=i*2; ② 

解： 语句1的频度是1,  
设语句2的频度是f(n)
则：2^f(n)<=n; f(n)<=log2n    
取最大值f(n)=log2n,
T(n)=O(log2n )
```

## 空间复杂度
一个算法的空间复杂度(Space Complexity)S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。渐近空间复杂度也常常简称为空间复杂度。
**S(n) = O(f(n))**

空间复杂度(Space Complexity)是对一个算法在运行过程中**临时占用存储空间大小**的量度。一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。算法在运行过程中临时占用的存储空间随算法的不同而异，**有的算法只需要占用少量的临时工作单元，而且不随问题规模的大小而改变，我们称这种算法是“原地"进行的。**

```
public void reserse(int[] a, int[] b) {
    int n = a.length;
    for (int i = 0; i < n; i++) {
        b[i] = a[n - 1 - i];
    }
}
当程序调用 reserse() 方法时，要分配的内存空间包括：引用a、引用b、局部变量n、局部变量i
因此 f(n)=4 ，4为常量。所以该算法的空间复杂度 S(n)=O(1)  
```
